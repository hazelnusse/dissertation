\chapter{Robot bicycle} \label{chapter4}

\section{Introduction and motivation} \label{rb:sec:intro}

The Whipple bicycle model qualitatively predicts behavior commonly observed in
physical bicycles such as a stable speed range and counter steer. To
quantitatively assess the accuracy of these predictions, in as controlled a
setting as possible, a robot bicycle was constructed. By \textit{robot
bicycle}, we simply mean a bicycle that can balance without a human rider; this key
feature permits experiments to be performed where dynamic quantities can be
measured without the influence of undesirable and difficult to measure human
inputs such as limb motion. Measurement of the bicycle motion that results from
the application of precisely known bicycle inputs permits direct comparisons to
predictions of the Whipple model without the need to model the human.
Experiments such as those conducted by Kooijman~\cite{Kooijman2007}, wherein a
riderless bicycle was pushed and ``ghost ridden'', do not maintain a constant
speed (the bicycle decelerates as soon as it is released by the pusher), nor
can a specific initial speed be set easily or precisely. Additionally,
in~\cite{Kooijman2007}, only the uncontrolled bicycle dynamics were examined;
as such, it was limited to speeds for which the uncontrolled bicycle is stable.
This work extends the work of~\cite{Kooijman2007} by accurately maintaining a
constant speed, and stabilizing the bicycle for speeds below the weave speed.

% TODO: motivate more discuss system identification
% if you remove the rider, the bicycle has a single input
% talk about system id
% bicycle is unstable
% control must be based upon some model of the bicycle
% for some frequencies, the model is sufficient (low bandwidth control
% for others it is not (high frequencies not predicted by the model)

This chapter describes the design and construction (mechanical, electrical, and
software) of the robot bicycle and presents data collected in a set of experiments.
Physical parameter measurement, sensor calibration, and all mechanical and
electrical components (purchased and fabricated) are documented here. The
mechanical and electrical sections are somewhat low level and tedious but are
included for completeness. Readers interested in the high level control system
design may consider skipping to \autoref{rb:sec:control}. Finally, a
description and analysis of a set of experiments is presented.

\section{Mechanical construction} \label{rb:sec:mec}
\subsection{Design} \label{rb:subsec:mecdesign}
The robot bicycle is shown in Figures
\ref{rb:img:rightside}-\ref{rb:img:leftsidecloseup}. Where possible, readily
available bicycle parts were used. A number of components were fabricated to
interface standard bicycle parts (frame, fork steer tube, disc brake tabs) with
equipment not typically found on a bicycle (batteries, fork motor, safety
casters, and electrical equipment). This section provides a high level overview
of the construction; more details of each subsystem can be found in the
subsequent subsections pertaining to each piece of equipment.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/IMG_20120928_153020.jpg}
  \caption{Robot bicycle viewed from the right side.}
  \label{rb:img:rightside}
\end{figure}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth,angle=-90]{images/IMG_20120928_153146.jpg}
  \caption[Robot bicycle viewed from the rear right side.]{Robot bicycle viewed
  from the rear right side. The wireless antenna is visible behind the
  batteries, and the attachment of the training wheel struts to the bicycle frame
  can also be seen.}
  \label{rb:img:rearrightside}
\end{figure}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth,angle=-90]{images/IMG_20120928_153405.jpg}
  \caption{Robot bicycle viewed from the rear.}
  \label{rb:img:rear}
\end{figure}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth,angle=-90]{images/IMG_20120928_153321.jpg}
  \caption[Robot bicycle viewed from the rear left.]{Robot bicycle viewed from
    the rear left. The motor wiring exits the left side of the rear wheel axle.
    The rear wheel optical encoder is mounted to the rear disc brake tabs and
    is driven by the rear wheel with a toothed kevlar belt combined with 100
    tooth and 25 tooth pulleys.}
  \label{rb:img:rearleftside}
\end{figure}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/IMG_20120928_153336.jpg}
  \caption[Battery plate, fork motor mount, and digital motor
    drives.]{Close up of battery plate, fork motor mount, and digital motor
    drives. The cylindrical plug interfacing the fork motor spindle and the fork
    steer tube is visible inside the aluminum box section directly beneath the
    steer motor.}
  \label{rb:img:leftsidecloseup}
\end{figure}

A Surly 4130 cromoly steel bicycle frame and fork were used~\cite{Surly2009}.
The frame and fork permit the use of 26'' or 700c wheels, cantilever or disc
brakes, and were chosen because its rugged steel construction permitted
modification without fear of compromising its structural integrity. The frame
was modified by welding an 18 gauge mild steel sheet to the inside of the front
triangle to provide a surface on which to mount the digital motor drives,
microcontroller development board and batteries.

To prevent damage to the robot bicycle in the case of a fall, custom training
wheels were designed and built. The training wheels were composed of casters
positioned approximately 18'' from the frame plane and roughly even with the
bottom bracket. The height of the casters permitted the bicycle to lean
approximately 20$^{\circ}$ before they touched the ground. Each caster wheel
was bolted to a 2'' long 2''x4'' aluminum box section which was in turn bolted
to one side of a small vertical steel plate. On the other side of the steel
plate, three 1/2''x0.0625'' 4130 cromoly steel round tubes were welded -- each
tube connected the steel plate (and hence the casters) to the bicycle frame and
provided sufficient strength and rigidity to handle the loads transmitted
during a fall. Welded to the inboard ends of the three 1/2'' tubes were
brackets which interfaced with the seat tube, down tube, and bottom bracket. The
brackets on either side of the frame were bolted together, thereby sandwiching
the bicycle frame.

Other custom-fabricated mechanical components were the wheel optical encoder
mounts, fork motor mounting hardware, and battery support plate. The details of
each of these components are discussed in \ref{rb:subsec:sensors},
\ref{rb:subsec:actuators}, and \ref{rb:subsec:batteries}, respectively.

\subsection{Physical parameter measurement} \label{rb:subsec:parameters}
The twenty three physical parameters (described in \hyperref[chapter2]{Chapter 2}) of the
robot bicycle were estimated by measuring first the benchmark parameter set,
and then converting those parameters to the gyrostat parameter set using the
equations presented in \autoref{model:parameter_conversion}. It was assumed
that the wheel minor radius was zero (i.e., that the wheels were knife edged).
The resulting parameters are presented in \autoref{rb:tab:parameters}.
\begin{table}[htbp]
  \centering
  \begin{tabular}{rccl}
    \toprule
    & {Rear gyrostat} & {Front gyrostat} & {Units} \\
    \midrule
    $I_{xx}$ &  1.542 &   0.183 & \si{\kg\m\squared} \\
    $I_{yy}$ &  3.557 &   0.226 & \si{\kg\m\squared} \\
    $I_{zz}$ &  3.014 &   0.069 & \si{\kg\m\squared} \\
    $I_{xz}$ &  0.839 &  -0.010 & \si{\kg\m\squared} \\
         $J$ &  0.114 &   0.092 & \si{\kg\m\squared} \\
         $m$ & 34.1   &   2.95  & \si{\kg}     \\
         $R$ &  0.336 &   0.336 & \si{\m}      \\
         $r$ &  0     &   0     & \si{\m}\\
         $a$ &  0.514 &  -0.021 & \si{\m}\\
         $b$ & -0.219 &  -0.152 & \si{\m}\\
         $c$ &  0.963 &  -0.048 & \si{\m}\\
         $l_s$ & \multicolumn{2}{c}{0.343} &  \si{\m} \\
    \bottomrule
  \end{tabular}
  \caption{Robot bicycle physical parameters.}
  \label{rb:tab:parameters}
\end{table}
\section{Electrical system description} \label{rb:sec:elec}
\subsection{Microcontroller} \label{rb:subsec:mcu} All functionality related to
control, measurement, and user interaction was implemented by programming an
Olimex STM32-H407~\cite{OlimexSTM32H407} development board. A summary of the
board functionality utilized is shown in Table \ref{rb:tab:mcu}.
\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|l|}
    \hline
    & ST Microelectronics STM32F407ZGT6 @ \SI{168}{\MHz} \\
    CPU & 1MiB flash memory, 192KiB ram, 32-bit memory address space \\
        & Thumb-2 instruction set, single precision floating point \\
    \hline
           & 3 x 16-bit timers in quadrature counting mode \\
           Timers & 32-bit count up timer @ \SI{4}{M\Hz} \\
           & PWM generation @ \SI{2.563}{\kHz}; $2^{16} - 1$ distinct duty cycles \\
    \hline
                   & UART peripheral (115,200 baud 8N1) to XBee Pro radio \\
                   Communication  & I2C peripheral @ \SI{400}{\kHz} to communicate with IMU \\
                   & SDIO peripheral to log data to micro SD flash memory card \\
                   & JTAG peripheral for flashing and debugging programs \\
    \hline
    General Purpose & Input: momentary switch, motor faults, fork encoder index \\
                    & Outputs: motor enable and direction, lean and steer LEDs \\
    \hline
  \end{tabular}
  \caption{Microcontroller development board functionality.}
  \label{rb:tab:mcu}
\end{table}
The C++11~\cite{C++11} programming language was used to implement all
functionality executed on the development board CPU. Certain language features
such as dynamic memory allocation, runtime type information, and exceptions
were not used due to associated overhead (generated code size or runtime
efficiency). The compiler Version 4.7 (update 2) of the GCC ARM
Embedded~\cite{gccARMEmbedded} tool chain was used to compile and link source
code to machine executable code. This ARM maintained version of GCC is
customized to generate efficient machine instructions for ARM embedded
processors.

The real time operating system ChibiOS/RT~\cite{ChibiOS} provided functionality
for concurrent execution, thread synchronization primitives, a file system for
data logging, an extensible interactive serial shell, and a high level
interface to the development board hardware peripherals (UART, I2C, SDIO, and
GPIOs). ChibiOS/RT directly supports a large number of development boards,
including the Olimex STM32-H407, which made building and running test code
convenient and relatively painless.  Additionally, the very active user
community and excellent documentation of ChibiOS/RT made it easy to
troubleshoot problems, ask questions, and get help while developing the
firmware.

The development board was attached to the right side of the sheet in the front
triangle of the frame. Slightly above the development board on the electrical
sheet was a small electrical prototype board which held several small
integrated circuits, Molex connector housings, and two LEDs. The prototype
board connections were soldered directly to the development board so they
effectively acted as a single unit. The Molex connector housings connected
several units to the microcontroller: 1) the optical encoders from both wheels
and fork, 2) the XBee wireless radio, and 3) the enable, fault, direction, and
signal ground pins from the digital motor drives. Wired directly to the
microcontroller development board was a small 7.2V battery
(\autoref{rb:subsec:batteries}) and the inertial measurement unit
(\autoref{rb:subsec:sensors}).

\subsection{Sensors} \label{rb:subsec:sensors}
The robot bicycle was equipped with three optical encoders which measured the
wheel angles and the steer angle. All three optical encoders were
differentially signalled for noise robustness. The front wheel encoder was mounted
to the fork but was left disconnected during all experiments due to risk of
damage when the front fork spun more than 180 degrees from straight ahead
(which happened several times in the testing phase of the robot bicycle
design). The steer angle encoder was integrated into the steer
motor~\cite{TeknicM3441} with the optical disc fixed to the motor shaft and
provided 20000 quadrature counts per revolution (\num{\pi e-4} rad / quadrature
count) as well as an index signal once per revolution. The wheel optical
encoders~\cite{USDigitalH5} provided an effective 800 quadrature counts per
revolution (\num{.25 \pi e-2} rad / quadrature count) without an index channel. The
wheel encoders were mounted with a custom aluminum adapter to the frame and
fork disc brake mounting tabs. The rear wheel optical encoder is visible in
\autoref{rb:img:rearleftside}; the front wheel optical encoder was mounted
similarly. Since the wheels were symmetric about their axis of rotation, no
calibration was needed for wheel encoders.

The steer encoder was calibrated whenever the cylindrical plug interfacing the
fork motor spindle to the fork steer tube was moved (this was only moved twice,
so only two calibrations were done; the cylindrical plug is visible in
\autoref{rb:img:leftsidecloseup}). A square T fixture was built to hold the
front wheel axle parallel with the rear wheel axle; this was defined to be the
zero steer configuration. The fixture can be seen in
\autoref{rb:img:calibration}. The steer angle calibration involved the
following steps:
\begin{itemize}
  \item Suspend the bicycle frame from the ceiling and remove both wheels.
  \item Rigidly mount the steer calibration fixture into the wheel dropouts,
    thereby setting the steer angle $\delta=0$.
  \item Turn the microcontroller on and issue the \verb|calibrate| (see
    \autoref{rb:subsec:ui} command. This calls a function which zeros the
    steer encoder count and waits for the steer encoder index.
  \item Remove the fixture from the front dropouts, and rotate the fork left to
    right 16 times. This causes the \verb|calibrate| command to record the
    steer encoder count each time the steer index signal transitions from low
    to high or high to low.
  \item Record the steer offset presented by the \verb|calibrate| function. The
    offset is the signed integer number of quadrature counts the index is away
    from steer $\delta=0$.
\end{itemize}
On microcontroller reset, the steer encoder count is set to zero regardless of
the position of the fork. By permanently recording the number of quadrature
counts the steer index is from the zero steer configuration, this offset
can be set during a fork homing procedure when the steer index is triggered.
This functionality was implemented in the \verb|homefork| function and was run
every time the microcontroller was reset.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/20130711_163732_2.jpg}
  \caption[Calibration of steer angle encoder, accelerometer, and rate
    gyroscope.]{Calibration of steer angle encoder, accelerometer, and rate
    gyroscope ($\phi=-\pi/2$ configuration). The steer calibration fixture
    ensured $\delta=0$ and provided surfaces to rest the bubble levels (visible
    on far side of bicycle frame). Two turnbuckles were used to make minor
    orientation adjustments to level the frame (visible on left side of image).}
  \label{rb:img:calibration}
\end{figure}

A combined rate gyroscope and accelerometer MEMS
sensor~\cite{InvensenseMPU6050} was fixed to the underside of the battery pack
plate as shown in \autoref{rb:img:imuplacement}. The gyroscope and
accelerometer sensor axes were assumed to be aligned with each other since they
are manufactured on the same piece of silicon. The sensor $\uv{s}{x}-\uv{s}{y}$
plane was approximately parallel to the plane of the battery plate, with
$\uv{s}{y}$ pointed approximately forward, $\uv{s}{y}$ to the left, and
$\uv{s}{z}$ down.

As described in Chapter 1, the bicycle model introduces set of dextral unit
vectors fixed to the rear frame $R$ of the bicycle, with $\uv{r}{z}$ parallel to
the steer axis and down, $\uv{r}{y}$ perpendicular to the frame plane and to the
right, and $\uv{r}{x} = \uv{r}{y} \times \uv{r}{z}$ ($\uv{r}{x}$ points forward and
slightly up when the bicycle is in the reference configuration). Fixed to the sensor $S$
are a set of dextral unit vectors with $\uv{s}{x}$ and $\uv{s}{y}$ in the plane
of the integrated circuit, and $\uv{s}{z}$ normal to the plane of the integrated
circuit. To orient the sensor relative to the bicycle, first align $S$ with
$R$, then apply the following successive body-fixed ZXY rotations: $\alpha -
\pi/2$, $\beta$, $\gamma$. The first rotation was offset by $-\pi/2$ so that
all three angles were near zero.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=.6\textwidth,angle=90]{images/IMG_20130325_195226.jpg}
  \caption[Rate gyroscope and accelerometer sensor placement.]{Rate gyroscope
    and accelerometer sensor placement on bottom of battery support plate. The
    top tube clamshell bracket is visible on the right side of the image
    (forward end of battery plate). On the left side of the image the seat post
    is partially visible. The mounting hardware for the battery box is also
    visible.}
  \label{rb:img:imuplacement}
\end{figure}

To determine the three angles $\alpha$, $\beta$, and $\gamma$, the static
acceleration was measured in three sensor directions ($\uv{s}{x}$, $\uv{s}{y}$,
$\uv{s}{z}$) in six unique orientations. The six orientations are those that
would be obtained if $R$ were aligned with and fixed to the edges of a perfect
cube and the cube was laid on a level surface on each of its six sides.  These
six configurations correspond to the following bicycle orientations:
$\phi=\pm\pi/2$ (frame plane horizontal), $\phi=0$ and $\theta_r = \{-\pi/2, 0,
\pi/2, \pi\}$ (frame plane vertical, two horizontal steer axis orientations and
two vertical steer axis orientations). The sensed acceleration in the three sensor
directions was recorded for approximately sixty seconds while the bicycle was
in each orientation.

The six orientations were obtained by suspending the bicycle by ropes from
three points of attachment and using a turnbuckle on two of the ropes to level
the desired surface in two directions. Two precision horizontal bubble levels
were attached to the frame 90 degrees apart to permit levelling in both
directions.  Once levelled, the bicycle was left to rest for approximately 5
minutes to allow for small swinging and twisting oscillations to die out; this
was also aided by suspending a weight from the frame with fishing line and
hanging it into a bucket of water. The bucket of water provided some
dissipation which helped damp out vibrations. Once stationary (within the
limits of the vibrating building), data collection was initiated.

When at rest, the accelerometer senses the gravitational field as if it were
accelerating \textit{upwards} at $g$, this corresponds to $-g\uv{n}{z}$.
Resolving $-g\uv{n}{z}$ into the three sensor measurement directions yields
\begin{align}
  \label{rb:eq:imux}
  -g\uv{n}{z} \cdot \uv{s}{x} &= g \left(- s_{\alpha}
s_{\beta} s_{\gamma}
s_{\phi} + s_{\alpha}
s_{\theta} c_{\gamma}
c_{\phi} + s_{\beta}
s_{\gamma} s_{\theta}
c_{\alpha} c_{\phi} +
s_{\gamma} c_{\beta}
c_{\phi} c_{\theta} +
s_{\phi} c_{\alpha}
c_{\gamma}\right) \\
%
  \label{rb:eq:imuy}
  -g\uv{n}{z} \cdot \uv{s}{y} &= g \left(- s_{\alpha}
s_{\phi} c_{\beta} -
s_{\beta} c_{\phi}
c_{\theta} + s_{\theta}
c_{\alpha} c_{\beta}
c_{\phi}\right) \\
%
  \label{rb:eq:imuz}
  -g\uv{n}{z} \cdot \uv{s}{z} &= g \left(s_{\alpha}
s_{\beta} s_{\phi}
c_{\gamma} + s_{\alpha}
s_{\gamma} s_{\theta}
c_{\phi} - s_{\beta}
s_{\theta} c_{\alpha}
c_{\gamma} c_{\phi} +
s_{\gamma} s_{\phi}
c_{\alpha} - c_{\beta}
c_{\gamma} c_{\phi}
c_{\theta}\right)
\end{align}
Where $s_{x}$ and $c_{x}$, $x=\alpha,\beta,\gamma,\phi,\theta$ are
abbreviations of $\sin{x}$ and $\cos{x}$. The goal of the calibration was to
convert the measured acceleration to the true acceleration, and for this reason
the following slightly non traditional (yet equally representative) form of the
acceleration sensor model was used
\begin{align}
  \label{rb:eq:sensormodel}
  \left[
    \begin{matrix}
      -g\uv{n}{z} \cdot \uv{s}{x} \\
      -g\uv{n}{z} \cdot \uv{s}{y} \\
      -g\uv{n}{z} \cdot \uv{s}{z}
    \end{matrix}
  \right]
  &=
  \left[
    \begin{matrix}
      S_{xx} & S_{xy} & S_{xz}\\
      S_{xy} & S_{yy} & S_{yz}\\
      S_{xz} & S_{yz} & S_{zz}
    \end{matrix}
  \right]
  \left[
    \begin{matrix}
      a_{x} \\
      a_{y} \\
      a_{z}
    \end{matrix}
  \right]
  +
  \left[
    \begin{matrix}
      b_{x} \\
      b_{y} \\
      b_{z}
    \end{matrix}
  \right]
\end{align}
where $a_x, a_y, a_z$ are the raw sensor measurements (in units of bits), $b_x,
b_y, b_z$ are biases (in units of m/s$^2$), $S_{xx}, S_{yy}, S_{zz}$ are the
sensitivities, and $S_{xy}, S_{yz}, S_{xz}$ are the cross axis sensitivities,
both of which have units of m/s$^2$/bit. Cross axis sensor symmetry was
assumed, i.e., $S_{xy} = S_{yx}$.

Equating the right side of Equations \ref{rb:eq:imux}-\ref{rb:eq:imuz} with the
right side of \autoref{rb:eq:sensormodel}, evaluating at the value of lean
$\phi$ and pitch $\theta$ corresponding with a particular configuration, and
taking the time series mean of each of the raw measurements $a_x, a_y, a_z$, we
obtain three equations with twelve unknowns. Repeating for each of the six
configurations, we obtain an overdetermined system of eighteen equations in
twelve unknowns. The twelve unknowns are the six sensitivities, the three
biases, and the three orientation angles relating the sensor frame to the
bicycle frame. This overdetermined system of equations was solved by the method
of least squares to obtain the following sensitivities, biases, and orientation
angles
\begin{align}
  \left[
    \begin{matrix}
      S_{xx} \\
      S_{yy} \\
      S_{zz} \\
      S_{xy} \\
      S_{yz} \\
      S_{xz}
    \end{matrix}
  \right]
  &=
  \left[
    \begin{matrix}
      \num{5.9898e-4} \\
      \num{5.9534e-4} \\
      \num{5.8288e-4} \\
      \num{-5.4766e-7} \\
      \num{-1.6455e-6} \\
      \num{1.9272e-6}
    \end{matrix}
  \right] \text{m/s$^2$/bit} \\
  \left[
    \begin{matrix}
      b_{x} \\
      b_{y} \\
      b_{z}
    \end{matrix}
  \right]
  &=
  \left[
    \begin{matrix}
      -0.5700 \\
       0.0514 \\
       1.1690
    \end{matrix}
  \right] \text{\si{m/s^2}} \\
  \left[
    \begin{matrix}
      \alpha \\
      \beta \\
      \gamma
    \end{matrix}
  \right]
  &=
  \left[
    \begin{matrix}
      0.0031 \\
      0.3230 \\
     -0.0182
    \end{matrix}
  \right] \text{rad}
\end{align}
The diagonal entries of $S$ were very close to the manufacturer specified
sensitivity of \num{5.9876e-4} m/s$^2$/bit. The diagonal entries were greater than
the off-diagonal entries by more than two orders of magnitude, indicating the
cross axis sensitivity was less than 1\%, also in line with the manufacturers
specifications. The means of three rate gyroscope measurements axes were
computed for each static configuration, and were found to be independent of
configuration (as expected). These means were used as biases for the
measurement of the bicycle frame angular velocity and were found to be
\begin{align}
  E[\omega_x] &= -0.1204\text{ rad/s}\\
  E[\omega_y] &=  0.0316 \text{ rad/s}\\
  E[\omega_z] &=  0.0100 \text{ rad/s}
\end{align}
Since a rate table or other convenient means of calibrating the gyroscope
sensitivities was not available, the manufacturer published gyroscope
sensitivities were used.

Two LEDs and a momentary switch were mounted on the right side of the bicycle.
The green LED was illuminated when the lateral acceleration was relatively
small compared to the total acceleration: $\frac{|\bs{a} \cdot
\uv{r}{y}|}{||\bs{a}||} < \frac{\pi}{180}$; this visually indicated when the
bicycle frame plane was nearly vertical. Similarly, the yellow LED was
illuminated when the steer angle was less than 1$^\circ = \frac{\pi}{180}$ rad.
Finally, the momentary switch was mounted on the right side of the steer motor
mount. When depressed, the switch grounded a microcontroller pin and indicated
that the bicycle was being balanced manually; when released, the pin state was
pulled up to +3.3V and indicated the bicycle was not being balanced manually.
The state of this pin was sampled and recorded along with all other sensor
signals; when the switch was closed, a 0 was recorded, when the switch was
open, a 1 was recorded (see \autoref{rb:fig:run000a} for an example of the
signal).

\subsection{Actuators} \label{rb:subsec:actuators}
The robot bicycle was equipped with a rear wheel hub motor to drive the rear
wheel and a fork motor to steer the bicycle. Both motors were brush-less DC
motors and were interfaced to the microcontroller with Copley Controls digital
motor drives (fork: ACJ-055-18~\cite{CopleyACJ}, rear wheel:
ADP-090-36~\cite{CopleyADP}). Both digital motor drives were configured in
current control mode and internally implemented a PI current (with gains
automatically selected via manufacturer software based upon motor parameters)
controller that operated at \SI{30}{\kHz}. The current commands were generated by the
microcontroller as 3.3V pulse width modulated (PWM) signals which were
converted by the motor drives to the appropriate high voltage, high current PWM
signals to the motor windings. The bicycle control system was designed to
generate applied joint torques as control signals, which were then scaled by
the respective motor torque constants before generating the current command PWM
signal.

The rear wheel was built with an electric hub motor~\cite{AmpedBikes}. The
manufacturer supplied rim and spokes were of extremely low quality (very weak,
untrue, and noticeably inertially non-symmetric), so they were replaced with DT
Swiss \SI{2.0}{\mm} stainless steel spokes and Mavic model A719, 700c diameter, 36 hole
rim. The rear hub axle served as the motor stator and armature with the three
motor power leads exiting the left side of the axle. The motor field magnets
were fixed to the inside of the hub shell and rotated along with the spokes,
rim, and tire when current was applied to the motor windings. This motor
configuration is commonly known as the ``outrunner'' configuration. No
manufacturer specifications were available for this motor, so the motor torque
constant was determined experimentally by applying a constant rear wheel
current $I_R$ with while the wheel was off the ground and measuring the angular
response. The spin inertia $J_r$ of the rear wheel was measured
(\autoref{rb:subsec:parameters}), and the idealized DC motor equation
$J_r\ddot{\theta}_r = K_t I_r$ was integrated twice with respect to time
(constant current assumed and $\theta_r(0)=\dot{\theta}_r(0) = 0$) to obtain
$\theta_r = \frac{K_t I_r}{2J_r}t^2$. A least squares fit was then used to
estimate $K_t=6.6$ Nm/A. Since a PI speed controller was implemented to control
rear wheel rate, it was not critical to know $K_t$ precisely (PI controllers
perform reasonably well even when system parameters are not well known); for
this reason we didn't expend any effort to more accurately determine $K_t$.

The fork motor~\cite{TeknicM3441} was bolted to an aluminum box section which
in turn was bolted to a custom upper headset. The custom upper headset was
pressed into the upper end of the bicycle steer tube with green Loctite to
ensure it would not twist relative to the frame when motor torques were
applied. In contrast to the rear wheel hub motor, the fork motor stator and
armature windings were fixed to the outer portion of the motor (fixed to the
bicycle frame) and the field magnets were fixed to the motor output shaft.  The
motor output shaft was equipped with a key-way which was mated to a circular
plug fixed to the inside of the steer tube. The circular plug was rigidly
attached to the steer tube in the same way a threaded bicycle stem wedge
expander attaches to the bicycle steer tube. The upper portion of the circular
plug (which mates with the motor shaft) was bored with a hole to match the
diameter of the motor output shaft, and an internal key-way was cut with a
wire-cut electrical discharge machine. Once the motor was secured, a set
screw was threaded into the upper portion of the plug to make contact with the
motor key. This design permitted the fork to be driven directly by the motor
without the use of a gearbox, and still permitted the motor to be removed
easily if necessary. Most importantly, the design had no backlash between the
motor shaft and the fork. A previous design was attempted which made use of a
precision gearbox, but it was found to have unacceptable levels of backlash.
Since the sign of the steer angle rate frequently changes during normal
operation of a bicycle, any backlash between the motor fork is extremely
undesirable.

\subsection{Batteries} \label{rb:subsec:batteries}
Four 12.0V sealed lead acid (SLA) batteries were wired in series and used to
power the motors and the digital motor drives. The SLA batteries were arranged
in a row of four and tightly bound to each other with duct tape and nylon
strapping. All other electronics were powered with a two-cell 7.2V lithium
polymer battery~\cite{Zippy5000} which was fastened to the right side of the
electrical panel with velcro and a small bungee cord.

The SLA batteries were securely fastened to the bicycle frame with a
1/4''x4''x18'' steel plate to support the bottom of the batteries, and a sheet
metal box on either end of the plate to maintain the lateral and longitudinal
position of the batteries relative to the plate. The plate was rigidly
attached to the bicycle frame with a steel seat post on the rear end and a
steel top tube bracket on the forward end. The seat post and bracket were
welded to the bottom of the plate such that when the seat post was inserted
into the frame, the top tube bracket interfaced with the top of the top tube to
align the steel plate symmetrically with respect to the bicycle frame. The top
tube bracket was a clamshell design, with the top half welded to the bottom of
the steel plate and the bottom half placed on the underside of the top tube and
then bolted to the top half, thereby securing the plate to the tube (see
\autoref{rb:img:imuplacement}). When the bicycle was in the upright reference 
configuration, the battery plate was approximately horizontal. In addition to
the battery box to maintain the lateral and longitudinal position of the
batteries with respect to the frame, nylon straps were used to secure the
batteries onto the plate.

\subsection{Wireless communication} \label{rb:subsec:wireless}
A pair of XBee Pro~\cite{XBeePro} wireless radios were used as a serial cable
replacement between the robot bicycle and a nearby laptop computer. Commands
were sent to the robot bicycle by typing them into a serial terminal
program~\cite{moserial} which transmitted the text as a simple character stream
through the USB port of the computer to the XBee Pro radio, which in turn
transmitted the commands wirelessly. A shell thread running on the robot
bicycle microcontroller monitored the serial port for received commands along
with optional command arguments. When a valid command was received, the
corresponding function was executed. A list of available commands are detailed
in \autoref{rb:subsec:ui}.


\section{Control system design} \label{rb:sec:control}
This section details the theoretical framework as well as the implementation
details of the control system for the robot bicycle. Lower level details and
user interface considerations are detailed in \autoref{rb:subsec:data} and
\autoref{rb:subsec:ui}.

\subsection{Data logging} \label{rb:subsec:data}
Data was written at \SI{200}{\Hz}, in binary format, to a single file per ``run'' on
the micro SD card. The data format used Google Protocol
Buffers~\cite{GoogleProtoBuf}, a platform independent data interchange format
used by Google. In addition to abstracting away platform dependent issues (byte
order, word size, etc.), this data format permitted data fields to be marked as
required or optional, and new data fields could be easily added without losing
the ability to easily work with old data collected without the new fields; this
ensured backwards compatibility for all data collected during the development
and refinement of the control system. This feature proved essential for
debugging errors and being able to inspect intermediate calculations during an
experiment to verify that we had implemented the control algorithms correctly.

The following is a partial list of the data that was recorded during each run;
the complete list is viewable in the source code.
\begin{description}
  \item[System time] Units of 0.25$\mu$s. Time elapsed since the beginning of
    data collection.
  \item[Computation time] Units of 0.25$\mu$s. Time elapsed from the
    beginning of each 5ms period until data collection and logging are
    complete. Used to ensure no calculations exceed the loop time.
  \item[System state] 32-bit unsigned integer whose bits are set high or low
    depending on the Boolean state of the following: Rear motor enable, steer
    motor enable, rear motor fault, steer motor fault, sample buffer
    encode/initialization/overflow error, momentary switch
    (\autoref{rb:subsec:sensors}), IMU communication error, filesystem error.
  \item[Rear wheel and steer angles and rates] Units of rad, rad/s. Rear wheel
    angular rate was determined by applying a low pass filter ($G_(s) = 20 \pi
    / (s + 20 \pi)$) to a 100ms moving average of an ideal derivative
    ($\dot{\theta}_r \approx \Delta\theta_r / \Delta t$). This effectively
    reduced the sample rate used for computing the rear wheel rate and hence
    reduced the effect of discretization error.  The moving average approach
    for obtaining the rear wheel rate was used because the discretization error
    of the rear wheel encoder was much higher than that of the steer angle
    encoder (800 vs. 20000 quadrature counts per revolution).  Also, commanded
    forward speeds (and by extension rear wheel rates) were constants, so the
    delay associated with a moving average did not present any problems.  Steer
    angular rate was obtained by a low pass filtered ideal derivative
    ($G(s)=20\pi s/(s+20\pi)$).
  \item[Commanded rear wheel rate and yaw rate] Units of rad/s. By
    default, these both start at 0 rad/s and change once the \verb|speed| or
    \verb|yaw_rate| commands are issued. Speed was specified in m/s but
    converted to rear wheel rate by dividing by rear wheel radius.
  \item[Motor torques] Units of N m. The torque commanded by rear motor
    controller and the fork motor controller. When generating the command to
    the digital motor drives, each signal was divided by the respective motor
    torque constant to calculate the current command in units of Amperes.
  \item[Frame angular velocity, sensor acceleration] Units of rad/s, m/s$^2$.
    Both quantities were computed by applying the sensitivities, biases, and
    direction cosine matrix to map raw measurements to appropriately scaled
    measurments in the bicycle body-fixed frame.
    (\autoref{rb:subsec:sensors}).
  \item[State estimates] Units of rad, rad / s. The four states of the
    linearized bicycle model were estimated at each time step and recorded;
    these state estimates were used in the feedback control law.
\end{description}

\section{Feedback control system}
Two independent control systems were implemented: A rear wheel rate controller
and a yaw rate controller. The \verb|speed| command was used to change the
commanded rear wheel rate, while the \verb|yaw_rate| command was used to change
the commanded yaw rate.

\subsection{Rear wheel rate controller} \label{rb:subsec:rw_control}
The rear wheel rate controller was a discrete time proportional-integral (PI)
controller with conditional integration. If the desired rear wheel torque
command exceeded the allowable torque, it was saturated and the integrator
state was not updated. This technique prevented integrator windup and was
simple to implement. The control law was
\begin{align}
  e_i &= \dot{\theta}_{r,i,\text{commanded}} - \dot{\theta}_{r,i} \\
  \tau_{i,\text{desired}} &= K_p e_i + x_{i-1}\\
  x_{i} &= \left\{
      \begin{matrix}
        x_{i-1} + \frac{K_p e_i (t_i - t_{i-1})}{T_i} & \text{if } |\tau_{i,\text{desired}}| \leq \tau_{\text{max}} \\
        x_{i-1} & \text{if } |\tau_{i,\text{desired}}| > \tau_{\text{max}}
      \end{matrix}
    \right. \\
  \tau_{i} &= \text{sat}(\tau_{i, \text{desired}}, \tau_{\text{max}})
\end{align}
where $x_{i}, \tau_{i,\text{desired}}$, and  $\tau_{i}$ are the integrator
state, the desired rear wheel torque, and the saturated rear wheel torque,
respectively, all for time step $i$. The maximum torque was limited by the
maximum current of the digital motor drive, $\tau_{\text{max}}$ = 158Nm (the
max motor current was configured to be 24.0A, and a rear motor torque constant
was estimated to be 6.6Nm/A). Through repeated experimentation, we found that a
gain of $K_p =50$ and an integration time constant of $T_i = 2000$ provided
sufficiently fast response, no steady state tracking error, and no noticeable
oscillatory behavior that can be present when integral action is used.

\subsection{Yaw rate controller} \label{rb:subsec:yr_control}
The yaw rate controller was implemented with an inner loop and an outer loop.
The inner loop was comprised of a full state estimator for the four bicycle
states using measurements of steer angle $\delta$ and lean rate $\dot{\phi}$,
and a full state feedback control law which used the state estimates instead of
the states. The stabilized inner loop was then inserted into an outer yaw rate
control loop which computed an additive control action based upon the error
between the commanded yaw rate $\dot{\psi}_c$ and the estimated yaw rate
$\dot{\hat{\psi}}$.  The block diagram for the complete system is shown in
\autoref{rb:fig:yr_block_diagram}. An additive sinusoidal disturbance torque
with user selectable amplitude $a_d$ and frequency $f$ (see the \verb|disturb|
command in \autoref{rb:subsec:ui}) was also incorporated into the design; by
default $a_d=0$ so that no disturbance was applied unless requested by the
user.

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
    block/.style={rectangle,draw,thick,minimum height=2em,minimum width=2em},
    sum/.style={circle,draw,thick,inner sep=0pt,minimum size=4mm},
    connector/.style={->,thick},
    guide/.style={},
    line/.style={thick}]
    % We start by placing nodes in a 5x10 matrix
    \matrix[ampersand replacement=\&, row sep=0.2cm, column sep=0.4cm] {
    %\node (disturbance_input) [coordinate, above=of inner_sum] {};
    % First row
    \node (input) [] {$\dot{\psi}_c$}; \&
    \node (outer_sum) [sum,label=135:$+$,label=225:$-$] {}; \&
    \node (pi_block) [block] {PI}; \&
    \node (inner_sum) [sum,label=45:$+$,label=135:$+$,label=225:$+$] {}; \&
    \&
    \node (branch_1) [coordinate] {}; \&
    \node (bicycle_block) [block,label=above:Bicycle dynamic model] {
    $\begin{aligned}\dot{x} &= Ax + B\tau_\delta\\
                          y &= C x
                        \end{aligned}$}; \& \& \& \\
    % Second row
    \& \& \& \& \& \node (u_route1) [coordinate] {}; \& \& \node (u_route2)
    [coordinate] {}; \& \node(y_route) [coordinate] {}; \& \\
    % Third row
    \& \& \& \& \node (gain_block) [block] {$K$}; \& \node(branch_2)
    [coordinate] {}; \&
    \node (estimator_block) [block,label=below:State estimator] {%
      $\dot{\hat{x}} = (A - LC)\hat{x} + B\tau_\delta + Ly$}; \& \& \& \\
    % Fourth row
      \& \& \node(C_yr) [block] {$C_{\dot{\psi}}$}; \& \& \& \& \& \& \& \\
    };
    % Place disturbance node above inner_sum, not using the matrix layout
    \node (disturbance) [above=of inner_sum] {$d = a_d\sin(2\pi f t)$};

    \draw[connector] (input.east) to (outer_sum.west);
    \draw[connector] (outer_sum.east) to node[auto] {$e_{\dot{\psi}}$} (pi_block.west);
    \draw[connector] (pi_block.east) to node[auto] {$r$} (inner_sum.west);
    \draw[connector] (disturbance.south) to (inner_sum.north);
    \draw[connector] (inner_sum.east) to node[auto] {$\tau_\delta$} (bicycle_block.west);
    \draw[connector] (estimator_block.west) to node[auto,swap] {$\hat{x}$} (gain_block.east);
    \draw[connector] (gain_block.west) -| node[auto] {$u$} (inner_sum.south);
    \draw[line] (branch_1) to (u_route1) to (u_route2);
    \draw[connector] (u_route2) |- ($(estimator_block.east) + (0mm, 1.5mm)$);

    \draw[line] (bicycle_block.east) -| node[auto] {$y$} (y_route);
    \draw[connector] (y_route) |- ($(estimator_block.east) - (0mm, 1.5mm)$);

    \draw[connector] (branch_2) |- (C_yr.east);
    \draw[connector] (C_yr.west) -| node[auto] {$\dot{\hat{\psi}}$} (outer_sum.south);

  \end{tikzpicture}
  \caption[Yaw rate control block diagram.]{Yaw rate control block diagram. The
    bicycle state is $x=[\phi, \delta, \dot{\phi}, \dot{\delta}]$, $\hat{x}$ is
    the state estimate, input to the bicycle is steer torque $\tau_\delta$, the
    measurements are $y = [\delta, \dot{\phi}]$.}
  \label{rb:fig:yr_block_diagram}
\end{figure}
The state feedback gain $K$ was computed by discretizing the plant model and
solving the discrete algebraic Riccati equation associated with the cost
function
\begin{align}
  J &= \sum_{i=1}^{\infty} (x_i^T Q x_i + u_i^T R u_i)
\end{align}
where $Q$ and $R$ were selected to be
\begin{align}
  Q &= \text{diag}(\frac{1}{(\frac{2\pi}{180})^{2}},
                   \frac{1}{(\frac{5\pi}{180})^{2}},
                   \frac{1}{(\frac{2\pi^2}{180})^{2}},
                   \frac{1}{(\frac{100\pi^2}{180})^{2}}) \\
  R &= \frac{1}{0.5^2}
\end{align}
This choice was selected following Bryson's rule~\cite{Bryson1975}; the terms
inside the $(\cdot)^2$'s in the denominator can be viewed as the ``maximum
allowable'' value for the corresponding state or control variable (e.g., the
``maximum allowable'' value for lean $\phi$ was $\frac{2\pi}{180}=2^{\circ}$).

Once the state feedback gain was computed, the closed loop eigenvalues of the
stabilized plant dynamics $A+BK$ were computed, and the estimator gain was
selected using pole placement. The poles of the estimator were all placed on
the negative real axis, equally spaced by 0.2 rad/s, and with the slowest estimator
pole being $3\min(\text{Re}(\sigma(A+BK)))$. This ensured the convergence of
the estimator was substantially faster than the controller dynamics.

With the bicycle dynamics stabilized by the inner loop, an outer loop was added
to track yaw rate. Yaw rate was chosen as the variable to track because it is a
natural way to describe both straight line motion ($\dot{\psi}=0$) as well as
steady turning motion ($\dot{\psi}=c\ne0$). The Matlab function
\verb|pidtune()| was used to compute the PI gains.

Since the dynamics of the bicycle vary with speed, this control system design
was performed at 101 speeds, logarithmically spaced between 0.5m/s and 10m/s.
All matrices in \autoref{rb:fig:yr_block_diagram} were output to a C++ file as
a sorted array of matrices parameterized by speed. This file was then compiled
into the firmware and gain scheduling was used to compute the actual control
law based on the measured speed. During a experimental run, the measured speed
was used to perform a binary search into the array to find the matrices
associated with speeds bounding the measured speed. A linear interpolation of
the state estimate update and control law were performed using these nearest
two speeds.  An implication of this is that estimation and control was not
possible below 0.5m/s. This turned out not to be a problem as long as the
bicycle was started from a near the upright reference configuration.

\subsection{User interface} \label{rb:subsec:ui}
The following list details the available commands and gives a brief description
of each.

\begin{description}
  \item[\Q{collect [filename]}] Begin main data collection and control loop and store
    data in optional argument \verb|filename| (if not supplied, data is stored in
    \verb|samples.dat|).
  \item[\Q{disable}] Immediately disable the motors and end data collection.
  \item[\Q{reset}] Perform a software reset of the microcontroller.
  \item[\Q{threads}] Show the memory address, stack address, priority, number
    of references to this thread, thread state, thread time in ticks, and the
    name of all currently running threads.
  \item[\Q{calibrate}] Begin the steer angle calibration routine (see
    \autoref{rb:subsec:sensors})
  \item[\Q{homefork}] Wait for the steer encoder index signal to set the steer calibration offset.
  \item[\Q{e_thresh v_e}] Set state estimation threshold speed to \verb|v_e| m/s.
    \verb|v_e| must be greater than or equal to 0.5m/s (the lowest speed
    for which linearized bicycle dynamics state space matrices were generated).
  \item[\Q{c_thresh v_c}] Set the threshold speed to \verb|v_c| m/s. Once the
    bicycle speed \verb|v| exceeds \verb|v_c| yaw rate control is enabled. Must
    be larger than estimation threshold speed.
  \item[\Q{thresh v_e v_c}] Simultaneously set state estimation and control threshold speeds.
  \item[\Q{disturb a_d f}] Set disturbance amplitude to
    \verb|a_d| \SI{1e-2}{\N\m}
    and disturbance frequency to \verb|f| \si{\Hz} (see
    \autoref{rb:fig:yr_block_diagram}).
  \item[\Q{speed v}] Set commanded speed in m/s. The control system will
    immediately attempt to track this speed until a fault occurs or the
    reference is changed by the user. On reset, the reference speed is set 0
    m/s.
  \item[\Q{speed_limit v d}] Set commanded speed to \verb|v| m/s and distance
    limit to \verb|d| meters. This works the same as \verb|speed| except that
    once the bicycle has travelled \verb|d| meters, the commanded speed is
    changed to 1.0 m/s, a speed which was easy to walk next to and catch the
    bicycle.
  \item[\Q{l_thresh t}] Set the lateral acceleration threshold to \verb|t|. At
    the beginning of each run, a green LED is illuminated when the bicycle
    lateral acceleration is below \verb|t| (with a default of \verb|t|=0.01
    m/s$^2$). This enables the bicycle to be initialized with as close to zero
    lean angle as possible. The sensed lateral acceleration is non-zero in
    static conditions because the accelerometer senses the gravitational field.
  \item[\Q{yaw_rate yr}] Set the commanded yaw rate in rad/s. On
    reset, reference yaw rate is 0 rad/s (straight line motion).

\end{description}

\section{Experiments} \label{rb:sec:experiments}

On July 13, 2013, twenty eight experimental runs were performed on the Dairy
Road basketball courts of the UC Davis campus (38.53794$^{\circ}$ North,
121.759475$^{\circ}$ West). Oliver Lee and Dr. Mont Hubbard were stationed at
the northeast corner of the east court, while I travelled east and west with
the robot bicycle each run. The bicycle can be seen balancing in
\autoref{rb:img:balancing}. To begin each run, Oliver Lee operated the laptop
and issued commands to configure the filename (following a naming convention
$<$run number$>$.dat), speed set point, distance to travel before reducing the
speed set point to \SI{1.0}{\m\per\s}, and optionally, an additive sinusoidal
disturbance steer torque of magnitude $a_d$ (\SI{1e-2}{\N\m}) and frequency
$f_d$ (\si{\Hz}). Dr. Hubbard took notes about each run and coordinated with
Oliver Lee to ensure commands issued to robot were consistent with his notes.
Prior to issuing a non-zero speed set point command, I held the bicycle near
the reference configuration (as indicated by two LED's which turned on when IMU
lateral acceleration and steer angle were less than \SI{0.01}{\m\per\s\squared}
and 1.0 deg, respectively), then ran along side the bicycle as it travelled
east to west or west to east. At the end of each run, I would turn of the main
power switches to each motor and catch the bicycle to prevent it from falling
on its casters.  The speed command issued by Oliver took two arguments: speed
set point and distance to travel before changing the set point to
\SI{1.0}{\m\per\s}. At \SI{1.0}{\m\per\s}, it was easy to manually switch off
the motors and catch the bicycle.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{images/balancing.jpg}
  \caption{Taking the robot bicycle on a jog.}
  \label{rb:img:balancing}
\end{figure}
\begin{center}
  \begin{longtable}{lllllll}
  \caption[Summary of experiments.]{Runs 000--010 utilized a yaw rate PI
    controller which explicitly specified the first 0db cross-over frequency to
    be \SI{0.1}{Hz} and utilized a disturbance torque $d = a_d \sin\left(2\pi
    t\right)$. The firmware was revised in Runs 011--014 to utilize a
    disturbance torque $d=a_d \sin\left(2\pi \left(t - t_i\right)\right)$ to
    ensure the initial disturbance began at 0 N m. For runs 015--028, the
    firmware was updated to use a yaw rate PI controller which did not
    explicitly specify the crossover frequency (instead it was selected
    automatically by Matlab based on the plant dynamics).}%
  \label{rb:table:experiments_summary} \\
  \toprule
  Run & Time (PST) & Speed (\si{\m\per\s}) & $a_d$ (\SI{1e-2}{\N\m}) & $f_d$ (\si{Hz}) & $x$ (\si{\m}) & Direction \\
  \midrule
  \endfirsthead
  \caption[]{(continued)} \\
  \toprule
  Run & Time (PST) & Speed (\si{\m\per\s}) & $a_d$ (\SI{1e-2}{\N\m}) & $f_d$ (\si{Hz}) & $x$ (\si{\m}) & Direction \\
  \midrule
  \endhead
  \midrule
  \endfoot
  \bottomrule
  \endlastfoot
  000 & 0641 & 2.0 & -- & -- & 30.0 & West \\
  001 & 0643 & 2.0 & -- & -- & 30.0 & West \\
  002 & 0644 & 3.0 & -- & -- & 30.0 & East \\
  003 & 0646 & 3.0 & -- & -- & 30.0 & West \\
  004 & 0647 & 4.0 & -- & -- & 30.0 & East \\
  005 & 0649 & 4.0 & -- & -- & 30.0 & West \\
  006 & 0650 & 4.0 & -- & -- & 60.0 & East \\
  007 & 0652 & 4.0 & -- & -- & 60.0 & East \\
  008 & 0656 & 2.0 & 0.5 & 1.0 & 30.0 & West \\
  009 & 0659 & 2.0 & 1.0 & 1.0 & 30.0 & East \\
  010 & 0701 & 2.0 & 1.0 & 1.0 & 30.0 & East \\
  011 & 0714 & 2.0 & 1.0 & 1.0 & 30.0 & West \\
  012 & 0718 & 2.0 & 5.0 & 1.0 & 30.0 & East \\
  013 & 0721 & 2.0 & 5.0 & 1.0 & 30.0 & West \\
  014 & 0725 & 2.0 & -5.0 & 1.0 & 30.0 & East \\
  015 & 0754 & 2.0 & -- & -- & 30.0 & West \\
  016 & 0756 & 2.0 & -- & -- & 30.0 & East \\
  017 & 0757 & 4.0 & -- & -- & 30.0 & West \\
  018 & 0800 & 2.0 & 5.0 & 1.0 & 30.0 & East \\
  019 & 0808 & 2.0 & 5.0 & 5.0 & 30.0 & West \\
  020 & 0813 & 2.0 & 10.0 & 1.0 & 30.0 & West \\
  021 & 0815 & 2.0 & -- & -- & 30.0 & West \\
  022 & 0816 & 1.0 & -- & -- & 30.0 & East \\
  023 & 0818 & 1.0 & -- & -- & 30.0 & East \\
  024 & 0821 & 2.0 & -- & -- & 5.0 & East \\
  025 & 0824 & 2.0 & -- & -- & 60.0 & West \\
  026 & 0825 & 3.0 & -- & -- & 50.0 & East \\
  027 & 0827 & 3.0 & -- & -- & 50.0 & East \\
  028 & 0829 & 3.0 & -- & -- & 50.0 & East \\
  \end{longtable}
\end{center}

\subsection{Example results} \label{rb:subsec:results}
The speed and steer angle response to a step in commanded speed is shown in
\autoref{rb:fig:run000a}. Prior to the step, the bicycle was held in a nearly
stationary upright zero steer configuration.  During the transition from
\SI{0}{\m\per\s} the bicycle was manually guided until a speed of approximately
\SI{1.0}{\m\per\s} was reached, at which point the bicycle was left to
accelerate further and balance solely via the yaw rate controller. The forward
speed was achieved only by the action of the rear wheel motor, no manual
pushing of the bicycle was performed.  This speed response was typical of all
runs.

As described in \autoref{rb:subsec:yr_control}, controller gains were computed
for forward speeds in the range of 0.5--10\si{\m\per\s}. However, due to the
difficulty of balancing at low speeds, we found that enabling the yaw rate
control system at speeds below \SI{1.0}{\m\per\s} proved problematic and would
result in drastic steer torques when accelerating from \SI{0}{\m\per\s} to
\SI{1.0}{\m\per\s}. For this reason, the threshold speed for state estimation
was set to \SI{1.0}{\m\per\s}, effectively disabling any yaw rate control
(i.e., $\tau_\delta = 0$) until the forward speed exceeded \SI{1.0}{\m\per\s}.
This threshold was a one time trigger -- once this speed was reached, the
controller remained enabled even if the speed went below \SI{1.0}{\m\per\s}
(for example, if the commanded speed was less than \SI{1.0}{\m\per\s}).

Once the forward speed exceeded the estimation threshold speed, state
estimation and control began. This event is visible in the steer angle estimate
\ref{estimated_steer} of \autoref{rb:fig:run000a} at the time when the
measured speed \ref{measured_v} crosses \SI{1.0}{\m\per\s} -- the steer angle estimate
initial condition is set to the steer angle measurement at that time step.
Similarly, the other estimator initial conditions were populated using the most
recently available measurements, lean rate $\dot{\hat{\phi}}$ (from rate
gyroscope), and steer rate $\dot{\delta}$ (from a low pass filtered numerical
time derivative of steer). No direct measurement of lean $\phi$ was available,
so the initial lean estimate $\hat{\phi}$ was zero for each run.  This latter
initial condition was the motivation for ensuring that the bicycle was as close
to $\phi=0$ at the beginning of each run -- doing so minimized the initial
estimation error and helped ensure a smooth start.

There is a noticeable difference between the measured steer
\ref{measured_steer} and estimated steer \ref{estimated_steer}. This
estimation error can be attributed several things: modelling errors,
measurement errors, and gain and phase response of the state estimator.
Modelling errors arise from inaccuracies of the measured physical parameters or
unaccounted-for dynamics. Measurement errors arise from discretization error,
imprecisely known sensor sensitivities and biases, and to a lesser degree,
un-modelled sensors dynamics (the frequencies of interest in the bicycle are
2-3 orders of magnitude smaller than the natural frequencies of typical MEMS
rate gyroscopes). These modelling errors result in a steady state estimation
error, similar to a pure proportional controller without any integral action.
Finally, the state estimate is attenuated and delayed by some amount from the
estimator inputs (steer torque $\tau_\delta$ and measurements of steer $\delta$
and lean rate $\dot{\phi}$); this is a trade-off that cannot be avoided without
introducing undesired amplification of high frequency sensor noise.

\begin{figure}
  \pgfplotsset{set layers}
  \pgfplotstableread{data/000-time-hw_button-steer-steer_est-v-v_c-20.00-30.00-decimated.txt}\runzerofirstplot
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      y axis style/.style={
      yticklabel style=#1,
      ylabel style=#1,
      y axis line style=#1,
      ytick style=#1
      },
      scale only axis,
      axis y line*=left,
      axis x line*=bottom,
      xlabel=Time (\si{\s}),
      ylabel=\si{\m\per\s},
      y axis style=red!75!black
    ]
    \addplot[red] table[x=time, y=v]{\runzerofirstplot};
    \label{measured_v}
    \addplot[red,dashed] table[x=time,y=v_c]{\runzerofirstplot};
    \label{commanded_v}
    \addplot[green] table[x=time,y=hw_button]{\runzerofirstplot};
    \label{hw_button}
    \end{axis}
    \begin{axis}[
      y axis style/.style={
        yticklabel style=#1,
        ylabel style=#1,
        y axis line style=#1,
        ytick style=#1
      },
      scale only axis,
      axis y line*=right,
      axis x line=none,
      ylabel=\si{rad},
      y axis style=blue!75!black,
      legend pos=outer north east
    ]
    \addplot[blue] table[x=time,y=steer]{\runzerofirstplot};
    \label{measured_steer}
    \addplot[blue,dashed] table[x=time,y=steer_est]{\runzerofirstplot};
    \label{estimated_steer}
    \end{axis}
  \end{tikzpicture}
  \caption[Run 000 speed and steer response.]{Run 000, measured speed
    \ref{measured_v} $v = -\dot{\theta}_r R_r$, commanded speed
    \ref{commanded_v} $v_c$, measured steer angle \ref{measured_steer}
    $\delta$, and estimated steer angle \ref{estimated_steer} $\hat{\delta}$.
    The momentary switch state \ref{hw_button} indicates the bicycle was
    released at $t = \SI{21.56}{\s}$, shortly before state estimation began at
    $t = \SI{21.62}{\s}$ (\ref{measured_v} $v = \SI{1.0}{\m\per\s}$). See
    \ref{rb:subsec:sensors} for a description of this switch.}
  \label{rb:fig:run000a}
\end{figure}

Estimates of steer rate $\dot{\hat{\delta}}$ and lean rate $\dot{\hat{\phi}}$ are
shown in \autoref{rb:fig:run000b}, \autoref{rb:fig:run000c}, respectively. In
comparison to the steer and steer estimate signals, these signals are much
noisier. Visible in both is the sudden change in the estimator state (at
$t = \SI{21.62}{\s}$) when the estimation threshold speed is reached.
\begin{figure}[htbp]
  \pgfplotsset{set layers}
  \pgfplotstableread{data/000-time-gyro_x-lean_rate_est-20.00-30.00-decimated.txt}\runzerosecondplot
  \centering
  \begin{tikzpicture}
    \begin{axis}[xlabel=Time (\si{\s}),
                 ylabel=Lean rate (\si{\radian\per\s}),
                 axis x line*=bottom,
                 axis y line*=left,
                 legend pos=outer north east]
    \addplot table[x=time,y=gyro_x]{\runzerosecondplot};
    \addlegendentry{Measured}
    \addplot table[x=time,y=lean_rate_est]{\runzerosecondplot};
    \addlegendentry{Estimated}
    \end{axis}
  \end{tikzpicture}
  \caption[Run 000 lean rate measured and estimated.]{Run 000 lean rate
    measured and estimated. The lean rate measurement was obtained by
    transforming rate gyroscope measurements from the sensor fixed axes to the
    lean frame fixed axes (constant frame pitch $\theta$ was assumed).}
  \label{rb:fig:run000b}
\end{figure}
\begin{figure}[htbp]
  \pgfplotstableread{data/000-time-steer_rate-steer_rate_est-20.00-30.00-decimated.txt}\runzerothirdplot
  \pgfplotsset{set layers}
  \centering
  \begin{tikzpicture}
    \begin{axis}[xlabel=Time (s),
                 ylabel=Steer rate (\si{\radian\per\s}),
                 axis x line*=bottom,
                 axis y line*=left,
                 legend pos=outer north east]
    \addplot table[x=time,y=steer_rate]{\runzerothirdplot};
    \addlegendentry{Measured}
    \addplot table[x=time,y=steer_rate_est]{\runzerothirdplot};
    \addlegendentry{Estimated}
    \end{axis}
  \end{tikzpicture}
  \caption[Run 000 steer rate measured and estimated.]{Run 000 steer rate
    measured and estimated. Measured steer rate was the result of applying a
    low pass filtered ideal derivative $G(s) = 20\pi s/(s+20\pi)$ to the steer
    angle measurement. The noise in this signal is directly proportional to
    steer angle quantization error and inversely proportional to sample period.}
  \label{rb:fig:run000c}
\end{figure}
The time response of rear wheel torque and the steer torque $\tau_\delta$ is
shown in \autoref{rb:fig:run000_torques}.
\begin{figure}
  \pgfplotsset{set layers}
  \pgfplotstableread{data/000-time-T_rw-T_rw_desired-T_s-T_s_desired-20.00-30.00-decimated.txt}\runzerotorque
  \centering
  \begin{tikzpicture}
    \begin{axis}[
      y axis style/.style={
      yticklabel style=#1,
      ylabel style=#1,
      y axis line style=#1,
      ytick style=#1
      },
      scale only axis,
      axis y line*=left,
      axis x line*=bottom,
      xlabel=Time (\si{\s}),
      ylabel=Rear wheel torque (\si{\N\m}),
      y axis style=red!75!black
    ]
    \addplot[red] table[x=time, y=T_rw]{\runzerotorque};
    \label{rb:fig:T_rw}
    \addplot[red,dashed] table[x=time,y=T_rw_desired]{\runzerotorque};
    \label{rb:fig:T_rw_desired}
    \end{axis}
    \begin{axis}[
      y axis style/.style={
        yticklabel style=#1,
        ylabel style=#1,
        y axis line style=#1,
        ytick style=#1
      },
      scale only axis,
      axis y line*=right,
      axis x line=none,
      ylabel=Steer torque (\si{\N\m}),
      y axis style=blue!75!black
    ]
    \addplot[blue] table[x=time,y=T_s]{\runzerotorque};
    \label{rb:fig:T_s}
    \end{axis}
  \end{tikzpicture}
  \caption[Run 000 rear wheel and steer torque response.]{Run 000 rear wheel
    and steer torque response. Rear wheel torque \ref{rb:fig:T_rw} and desired
    rear wheel torque \ref{rb:fig:T_rw_desired} (saturation occured for $t \in
    [\SI{20.88}{\s}, \SI{21.57}{\s}]$). Steer torque \ref{rb:fig:T_s} did not saturate. The
    effect of the positive initial spike in steer torque is visible in
    \autoref{rb:fig:run000a}, \autoref{rb:fig:run000b}, and
    \autoref{rb:fig:run000c}.}
  \label{rb:fig:run000_torques}
\end{figure}

\subsection{Discussion} \label{rb:subsec:discuss}
The transfer function from the input steer torque $\tau_\delta$ to an output
measurement (i.e., steer $\delta$ or lean rate $\dot{\phi}$) can be estimated
by computing the ratio of the forward discrete Fourier transform (DFT) of the
selected output to the forward DFT of the input steer torque.  Because the
dynamics are speed dependent, the selected input and output should be time series
data during which the speed is nearly constant. For $n$ real data points $x_0
\ldots x_{n-1}$, the forward DFT is given by
\begin{align} X_k &=
  \sum_{j=0}^{n-1} x_j e^{-2 \pi j k \sqrt{-1} / n} \quad k = 0 \ldots n-1
  \label{rb:dft}
\end{align}
The sequence $X_k$ possesses Hermitian symmetry ($X_k = X_{n-k}^*$), so half of
the output is redundant (the second half is the complex conjugate of the first
half, in reverse order). Therefore, the result of the DFT of a sequence of $n$
real numbers is a sequence of $\frac{n}{2} + 1$ complex numbers, where
$\frac{n}{2}$ is rounded down if $n$ is odd. The first element of this output
sequence, $X_0$ is always real and represents $n$ times the mean of the input
sequence $x_k$ (i.e., $X_0 = n E\{x_k\}$). The magnitude of each of the
remaining $\frac{n}{2}$ complex numbers is $\frac{1}{2}$ the magnitude of the
frequency response, at frequencies evenly spaced between 0 and the Nyquist
frequency $\frac{f_s}{2}$.  In practice, to obtain the magnitude portion of the
frequency response, one needs to compute $\frac{2}{n} |X_k|$ for $k = 1 \ldots
n/2$, and $\frac{1}{n} |X_0|$ for the DC component. However, to estimate a
transfer function given the DFT of the input and output of an assumed linear
system, only the ratio of the DFTs need to be considered, so this scaling is
unnecessary.

Estimates of $|\frac{\delta}{\tau_\delta}(j\omega)|$ and
$|\frac{\dot{\phi}}{\tau_\delta}(j\omega)|$ were computed for three different
commanded speeds: 1, 2, and 4 \si{\m\per\s}. The time series data was selected over a
time interval during which the forward speed of the bicycle was nearly
constant. Since the sampling frequency was \SI{200}{\Hz}, all frequency responses are
plotted up to \SI{100}{\Hz} (the Nyquist frequency).
\begin{figure}[htbp]
  \pgfplotstableread{data/024-time-T_s-gyro_x-steer-v-21.00-26.00-decimated.txt}\runtwentyfourtime
  \centering
  \begin{tikzpicture}
    \begin{axis}[xlabel=Time (\si{\s}),
        ylabel={\si{\radian}, \si{\radian\per\s}},
      scale only axis,
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=steerrollrate]
      \addplot table[x=time,y=steer] {\runtwentyfourtime}; \addlegendentry{Steer angle}
      \addplot table[x=time,y=gyro_x] {\runtwentyfourtime}; \addlegendentry{Lean rate}
    \end{axis}
    \begin{axis}[
      at={(steerrollrate.below south west)},
      yshift=-0.1cm,
      anchor=north west,
      scale only axis,
      xlabel=Time (\si{\s}),
      ylabel={torque (\si{\N\m}), speed (\si{\m\per\s})},
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=torquespeed]
      \addplot table[x=time,y=T_s] {\runtwentyfourtime}; \addlegendentry{Steer torque}
      \addplot table[x=time, y=v] {\runtwentyfourtime}; \addlegendentry{Forward speed}
    \end{axis}
  \end{tikzpicture}
  \caption[Steer, lean rate, steer torque time response at
    \SI{1.0}{\m\per\s}.]{Run 024 steer, lean rate, steer torque and speed
    response, $v_c=\SI{1.0}{\m\per\s}$. The run continued until $t=\SI{41}{\s}$
    with very similar response. Steer torque saturated repeatedly at
    $\tau_{\delta,\max}=\pm\SI{4.511}{\N\m}$.}
  \label{rb:fig:run024_tr}
\end{figure}
\begin{figure}[htbp]
  \pgfplotstableread{data/024-freq-T_s-gyro_x-steer-v-21.00-41.00-fft.txt}\runtwentyfourfreq
  \centering
  \begin{tikzpicture}
    \begin{axis}[xlabel=Frequency (Hz),
      ylabel=$|\frac{\delta}{\tau_\delta}|$,
      scale only axis,
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=torquetosteer]
      \addplot table[x=freq,y=steer] {\runtwentyfourfreq};
    \end{axis}
    \begin{axis}[
      at={(steerrollrate.below south west)},
      yshift=-0.1cm,
      anchor=north west,
      scale only axis,
      xlabel=Frequency (Hz),
      ylabel=$|\frac{\dot{\phi}}{\tau_\delta}|$,
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=torquetoleanrate]
      \addplot table[x=freq,y=gyro_x] {\runtwentyfourfreq};
    \end{axis}
  \end{tikzpicture}
  \caption[Steer and lean rate frequency response at
    \SI{1.0}{\m\per\s}.]{Run 024 steer and lean rate frequency response,
    $v_c=\SI{1.0}{\m\per\s}$.  DFT of steer, lean rate, and steer torque
    signals was computed for $t \in [\SI{21}{s}, \SI{41}{s}]$ (4001 time
    points).}
  \label{rb:fig:run024_fr}
\end{figure}

Control of a bicycle through steer torque alone is more difficult at low speeds
than at high speeds. This fact manifests itself in the control system as large
state feedback gains which increase noise sensitivity. This effect is clearly
apparent in \autoref{rb:fig:run024_tr} where high frequency, large magnitude
(saturating) steer torque oscillations were observed. The frequency response in
\autoref{rb:fig:run024_fr} exhibits sharp peaks at \SI{53}{\Hz} and
\SI{77}{\Hz} and generally has much more high frequency content than runs at
higher speeds. This indicates that the applied steer torque excited dynamics
that are not present in the Whipple bicycle model. The
$\frac{\delta}{\tau_\delta}$ transfer function exhibits stronger peaks in the
low frequency range than the $\frac{\dot{\phi}}{\tau_\delta}$ transfer
function; this may be due to the $\frac{1}{s}$-like dynamics (i.e., high gain at low
frequencies, \SI{-20}{\decibel\per decade} decay at high frequencies)
associated with this state being an angle as opposed to a rate.

\begin{figure}[htbp]
  \pgfplotstableread{data/025-time-T_s-gyro_x-steer-v-40.00-60.00-decimated.txt}\runseventime
  \centering
  \begin{tikzpicture}
    \begin{axis}[xlabel=Time (\si{\s}),
        ylabel={\si{\radian}, \si{\radian\per\s}},
      scale only axis,
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=steerrollrate]
      \addplot table[x=time,y=steer] {\runseventime}; \addlegendentry{Steer angle}
      \addplot table[x=time,y=gyro_x] {\runseventime}; \addlegendentry{Lean rate}
    \end{axis}
    \begin{axis}[
      at={(steerrollrate.below south west)},
      yshift=-0.1cm,
      anchor=north west,
      scale only axis,
      xlabel=Time (\si{\s}),
      ylabel={torque (\si{\N\m}), speed (\si{\m\per\s})},
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=torquespeed]
      \addplot table[x=time,y=T_s] {\runseventime}; \addlegendentry{Steer torque}
      \addplot table[x=time, y=v] {\runseventime}; \addlegendentry{Forward speed}
    \end{axis}
  \end{tikzpicture}
  \caption[Steer, lean rate, steer torque time response at \SI{4.0}{\m\per\s}.]{Run 025 steer,
    lean rate, steer torque and speed response, $v_c=\SI{2.0}{\m\per\s}$.}
  \label{rb:fig:run025_tr}
\end{figure}
\begin{figure}[htbp]
  \pgfplotstableread{data/025-freq-T_s-gyro_x-steer-v-40.00-60.00-fft.txt}\runsevenfreq
  \centering
  \begin{tikzpicture}
    \begin{axis}[xlabel=Frequency (\si{\Hz}),
      ylabel=$|\frac{\delta}{\tau_\delta}|$,
      scale only axis,
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=torquetosteer]
      \addplot table[x=freq,y=steer] {\runsevenfreq};
    \end{axis}
    \begin{axis}[
      at={(steerrollrate.below south west)},
      yshift=-0.1cm,
      anchor=north west,
      scale only axis,
      xlabel=Frequency (\si{\Hz}),
      ylabel=$|\frac{\dot{\phi}}{\tau_\delta}|$,
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=torquetoleanrate]
      \addplot table[x=freq,y=gyro_x] {\runsevenfreq};
    \end{axis}
  \end{tikzpicture}
  \caption[Steer and lean rate frequency response to
  $v_c=\SI{2.0}{\m\per\s}$.]{Run 025 steer and lean rate frequency response,
    $v_c=\SI{2.0}{\m\per\s}$.  DFT of steer, lean rate, and steer torque
    signals was computed for $t \in [\SI{40}{\s}, \SI{60}{\s}]$ (4001 time
  points).}
  \label{rb:fig:run025_fr}
\end{figure}

For a speed command of $v_c=\SI{2.0}{\m\per\s}$, the steer torque response is
much less noisy and does not saturate. There is a clear DC offset visible in
the steer torque in \autoref{rb:fig:run025_tr}. Despite this, the bicycle
travelled nearly in a straight line for approximately \SI{60}{\m}, indicating
that the yaw rate controller was driving the yaw rate $\dot{\psi}$ to zero (a
straight line). The steer torque bias was likely due to mass imbalance or frame
misalignment.  Possible sources of mass imbalance include the rear hub motor
(it unfortunately was not laterally symmetric, even though the rim and tire
were, see \autoref{rb:img:rear}), the electrical hardware on the frame sheet,
the batteries, and the training wheels. Possible sources of frame misalignment
include the wheel planes not being coplanar when steer $\delta=0$ as a result
of frame and fork construction. The steer magnitude frequency response
$|\frac{\delta}{\tau_\delta}|$ at $v_c=\SI{2.0}{\m\per\s}$ exhibits similar low
frequency characteristics as in the case of $v_c=\SI{1.0}{\m\per\s}$.  However,
$|\frac{\delta}{\tau_\delta}|$ is drastically different; this is likely due to
the steer torque bias that is more apparent when the steer torque oscillations
are less extreme as in the case when $v_c=\SI{1.0}{\m\per\s}$.

\begin{figure}[htbp]
  \pgfplotstableread{data/007-time-T_s-gyro_x-steer-v-21.00-31.00-decimated.txt}\runseventime
  \centering
  \begin{tikzpicture}
    \begin{axis}[xlabel=Time (s),
        ylabel={\si{\radian}, \si{\radian\per\s}},
      scale only axis,
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=steerrollrate]
      \addplot table[x=time,y=steer] {\runseventime}; \addlegendentry{Steer angle}
      \addplot table[x=time,y=gyro_x] {\runseventime}; \addlegendentry{Lean rate}
    \end{axis}
    \begin{axis}[
      at={(steerrollrate.below south west)},
      yshift=-0.1cm,
      anchor=north west,
      scale only axis,
      xlabel=Time (s),
      ylabel={torque (\si{\N\m}), speed (\si{\m\per\s})},
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=torquespeed]
      \addplot table[x=time,y=T_s] {\runseventime}; \addlegendentry{Steer torque}
      \addplot table[x=time, y=v] {\runseventime}; \addlegendentry{Forward speed}
    \end{axis}
  \end{tikzpicture}
  \caption[Steer, lean rate, steer torque time response at \SI{4.0}{\m\per\s}.]{Run 007 steer,
    lean rate, steer torque and speed response, $v_c=\SI{4.0}{\m\per\s}$.}
  \label{rb:fig:run007_tr}
\end{figure}
\begin{figure}[htbp]
  \pgfplotstableread{data/007-freq-T_s-gyro_x-steer-v-21.00-31.00-fft.txt}\runsevenfreq
  \centering
  \begin{tikzpicture}
    \begin{axis}[xlabel=Frequency (\si{\Hz}),
      ylabel=$|\frac{\delta}{\tau_\delta}|$,
      scale only axis,
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=torquetosteer]
      \addplot table[x=freq,y=steer] {\runsevenfreq};
    \end{axis}
    \begin{axis}[
      at={(steerrollrate.below south west)},
      yshift=-0.1cm,
      anchor=north west,
      scale only axis,
      xlabel=Frequency (\si{\Hz}),
      ylabel=$|\frac{\dot{\phi}}{\tau_\delta}|$,
      axis x line*=bottom,
      axis y line*=left,
      legend pos=outer north east,
      name=torquetoleanrate]
      \addplot table[x=freq,y=gyro_x] {\runsevenfreq};
    \end{axis}
  \end{tikzpicture}
  \caption[Steer and lean rate frequency response at \SI{4.0}{\m\per\s}.]{Run
    007 steer and lean rate frequency response, $v_c=\SI{4.0}{\m\per\s}$. DFT
    of steer, lean rate, and steer torque signals was computed for $t \in
    [\SI{21}{\s}, \SI{31}{\s}]$ (2001 time points).}
  \label{rb:fig:run007_fr}
\end{figure}

\autoref{rb:tab:runstats} indicates that the higher speeds result in smaller
mean and standard deviation of steer angle. This can be attributed to the fact
that the bicycle is closer to the stable speed range where no control action is
necessary to balance. The lean rate standard deviation $\sigma_{\dot{\phi}}$ is
also substantially decreased as speed increases. The steer torque mean
$\mu_{\tau_\delta}$ does not appear to be speed dependent and indicates that
mass imbalance is more likely the cause than geometric frame misalignment.

\begin{table}
  \centering
  \begin{tabular}{cccccc}
    \toprule
    Run &
    $v_c$ \si{\m\per\s} &
    $\mu_v \pm \sigma_v$ \si{\m\per\s} &
    $\mu_\delta \pm \sigma_\delta$ \si{\radian} &
    $\mu_{\dot{\phi}} \pm \sigma_{\dot{\phi}}$ \si{\radian\per\s} &
    $\mu_{\tau_\delta} \pm \sigma_{\tau_\delta}$ \si{\N\m} \\
    \midrule
%Signal  "v" mean =  0.959306 , std =  0.0157029 
%Signal  "steer" mean =  -0.0127641 , std =  0.155943 
%Signal  "gyro_x" mean =  0.000674937 , std =  0.104518 
%Signal  "T_s" mean =  0.157338 , std =  3.19504 
    024 &
    1.0 &
    0.96$\pm$0.02 &
    -0.0128$\pm$0.1559 &
    0.0007$\pm$0.1045 &
    0.16$\pm$3.20 \\
% 025
%Signal  "v" mean =  1.95683 , std =  0.0282297 
%Signal  "steer" mean =  -0.00702159 , std =  0.0153661 
%Signal  "gyro_x" mean =  -0.000207788 , std =  0.0107762 
%Signal  "T_s" mean =  0.160056 , std =  0.125208 
    025 &
    2.0 &
    1.96$\pm$0.03 &
    -0.0070$\pm$0.0153 &
    -0.0002$\pm$0.0108 &
    0.16$\pm$0.13 \\
% 007
%Signal  "v" mean =  3.94874 , std =  0.0224866 
%Signal  "steer" mean =  -0.00344272 , std =  0.00285794 
%Signal  "gyro_x" mean =  -0.0024786 , std =  0.00930448 
%Signal  "T_s" mean =  0.146077 , std =  0.116548 
    007 &
    4.0 &
    3.95$\pm$0.02 &
    -0.0034$\pm$0.0029 &
    -0.0025$\pm$0.0093 &
    0.15$\pm$0.12 \\
    \bottomrule
  \end{tabular}
  \caption{Mean and standard deviation of speed, steer, lean rate, and steer
  torque.}
  \label{rb:tab:runstats}
\end{table}

\subsection{Conclusions and future work} \label{rb:subsec:conclusions}
The robot bicycle has a robust control and data acquisition system that can be
the basis for more experiments. While the bicycle does balance and record data
reliably across a moderate range of speeds, there are a number of issues that
need to be addressed in order for quantitative system identification techniques
to be applied with any reasonable hope of success. Of primary concern is the
mass imbalance that is apparent by the steer torque bias. Additionally, the
rear wheel encoder was relatively low resolution (800 counts per wheel
revolution), and this directly affected the balance control because speed
measurement noise (due to discretization error) directly impacted the gain
scheduling algorithm used for the control of yaw rate and the lateral dynamics.
It is possible that some of the noise in the steer torque signal was induced by
the gain scheduling. Replacing the rear encoder with a higher resolution
version would directly address this issue.

Another implementation issue is the full state estimator. Especially in the
case of steer angle, this estimator was redundant. The steer rate estimate was
also relatively poor in comparison to a simple low pass filtered derivative of
the steer angle. Implementing a reduced order estimator to estimate only lean
angle and lean rate, the performance (i.e., bandwidth and accuracy) of the
estimator would be improved and likely contribute to overall better performance
of the state feedback law.

Finally, it should be mentioned that the conditions of the experiment were not
as well controlled as they ideally should have been. The experiments were
conducted early in the morning with very little wind, but ideally they would
have been conducted indoors on a smoother surface than the surface provided by
the outdoor basketball courts. Unfortunately, due to time limitations and
scheduling conflicts, we were unable to conduct experiments indoors at the UC
Davis Activities and Recreation Center (ARC).

Qualitatively, the frequency response obtained in the experiments indicates the
presence of dynamics besides those predicted by the Whipple model.  However,
the fact that the Whipple model was successfully used as the plant model for
the control system does indicate that at least for low bandwidth tasks, the
model can be used to reasonably describe the behavior of real bicycles.
However, the robustness of the control system was not rigorously tested through
disturbance inputs, and it may very well be that relatively minor disturbances
would destabilize the bicycle. To know this for sure, refinement of the
experimental conditions and hardware are needed. It is my sincere hope that the
project can be continued and taken further now that much of the groundwork is
in place.

